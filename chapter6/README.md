# 第六章 模块·组件化之路

### 为何要组件化

在做一件事之前我们一般都要搞清楚为什么要这么做，好处是什么，有哪些坑，这样才会有一个整体的认识，然后再决定要不要做。同样我们也要搞清楚到底需不需要实施组件化，那么就要先搞清楚什么是组件

### 组件的定义

组件是由一个或多个类构成，能完整描述一个业务场景，并能被其他业务场景复用的功能单位。组件就像是PC时代个人组装电脑时购买的一个个部件，比如内存，硬盘，CPU，显示器等，拿出其中任何一个部件都能被其他的PC所使用。

所以组件可以是个广义上的概念，并不一定是页面跳转，还可以是其他不具备UI属性的服务提供者，比如日志服务，VOIP服务，内存管理服务等等。说白了我们目标是站在更高的维度去封装功能单元。对这些功能单元进行进一步的分类，才能在具体的业务场景下做更合理的设计。

### 组件化的优点

纵观目前的已经在实施组件化的团队来看，大家的一般发展路径都是：前期项目小，需要快速迭代抢占市场，大家都是用传统的MVC架构去开发项目。等到后期项目越来越大，开发人数越来越多，会发现传统的开发方式导致代码管理混乱，发布、集成、测试越来越麻烦，被迫走向组件化的道路。

其实组件化也不是完全必须的，如果你的团队只是开发一个小项目，团队人数小于10个人，产品线也就是两三条，那么完全可以用传统开发方式来开发。但是如果你的团队在不断发展，产品线也越来越多的时候，预计后期可能会更多的时候，那么最好尽早把组件化提上议程。

摘自casa的建议：

>组件化方案在App业务稳定，且规模（业务规模和开发团队规模）增长初期去实施非常重要，它助于将复杂App分而治之，也有助于多人大型团队的协同开发。但组件化方案不适合在业务不稳定的情况下过早实施，至少要等产品已经经过MVP阶段时才适合实施组件化。因为业务不稳定意味着链路不稳定，在不稳定的链路上实施组件化会导致将来主业务产生变化时，全局性模块调度和重构会变得相对复杂。

其实组件化也没有多么高大上，和我们之前说的模块化差不多，就是把一些业务、基础功能剥离，划分为一个个的模块，然后通过pods的方式管理而已，同时要搭配一套后台的自动集成、发布、测试流程

一般当项目越来越大的时候，无可避免的会遇到如下的痛点：


* 团队成员提交代码冲突机率大

* CI 配合效果差

* 功能性代码多端无法复用

* 单仓库代码量大

* 代码冲突多，编译慢。

* 每一次拉下代码开发功能，开发完成准备提交代码时，往往有其他工程师提交了代码，需要重新拉去代码合并后再提交，即使开发一个很小的功能，也需要在整个工程里做编译和调试，效率较低。

* 迭代速度慢，耦合比较严重，无法单独测试。

* 各个业务模块之间互相引入，耦合严重。每次需要发版时，所有的业务线修改都需要全部回归，然后审查看是否出错，耗费大量时间。业务线之间相互依赖，可能会导致一个业务线必须等待另外一个业务线开发完某个功能才可以接着开发，无法并行开发。还有一个问题，就是耦合导致无法单独测试某个业务线，可能需要等到所有业务线开发完毕，才能统一测试，浪费测试资源



为了解决上述痛点，组件化应运而生，总体来说，组件化就是把整个项目进行拆分，分成一个个单独的可独立运行的组件，分开管理，减少依赖。 完成组件化之后，一般可达到如下效果：

* 加快编译速度，可以把不会经常变动的组件做成静态库，同时每个组件可以独立编译，不依赖于主工程或者其他组件

* 每个组件都可以选择自己擅长的开发模式（MVC / MVVM / MVP）

* 可以单独测试每个组件

* 多条业务线可以并行开发，提高开发效率

